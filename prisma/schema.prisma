generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int             @id @default(autoincrement())
  email            String          @unique
  password         String
  name             String?
  role             Role            @default(user)
  isAdmin          Boolean         @default(false)
  isLocked         Boolean         @default(false) @map("is_locked")
  deviceApprovalRequired Boolean   @default(true) @map("device_approval_required")
  createdAt        DateTime        @default(now()) @map("created_at")
  lastLogin        DateTime?       @map("last_login")
  lockUntil        DateTime?       @map("lock_until")
  loginAttempts    Int             @default(0)
  resetToken       String?         @map("reset_token")
  resetTokenExpire DateTime?       @map("reset_token_expire")
  updatedAt        DateTime?       @default(now()) @updatedAt @map("updated_at")
  maxDevices       Int             @default(1) @map("max_devices")
  checkpoints      Checkpoint[]
  fileAccesses     FileAccess[]
  activeSessions   ActiveSession[]
  deviceNotifications DeviceNotification[]

  @@map("users")
}

model AudioFile {
  id            Int          @id @default(autoincrement())
  filename      String
  path          String       @unique
  mimeType      String
  size          Int
  duration      Float
  title         String
  description   String?
  isPublic      Boolean      @default(false)
  isEncrypted   Boolean      @default(false)
  encryptionKey String?
  encryptionIV  String?
  encryptionTag String?      @map("encryption_tag")
  coverImagePath String?     @map("cover_image_path")
  coverImageBase64 String?   @map("cover_image_base64")
  coverImageMimeType String? @map("cover_image_mime_type")
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  checkpoints   Checkpoint[]
  fileAccesses  FileAccess[]
  chapters      AudioChapter[]
}

model FileAccess {
  id        Int       @id @default(autoincrement())
  userId    Int
  fileId    Int
  canView   Boolean   @default(true)
  grantedAt DateTime  @default(now())
  expiresAt DateTime?
  audioFile AudioFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, fileId])
}

model Checkpoint {
  id          Int       @id @default(autoincrement())
  fileId      Int
  userId      Int
  timestamp   Float
  name        String
  description String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  audioFile   AudioFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([fileId, timestamp, userId])
}

model AudioChapter {
  id            Int       @id @default(autoincrement())
  fileId        Int
  label         String
  startTime     Float
  endTime       Float?
  order         Int
  status        ChapterStatus @default(pending)
  encryptionKey String?   @map("encryption_key")
  encryptionIV  String?   @map("encryption_iv")
  encryptionTag String?   @map("encryption_tag")
  encryptedData Bytes?    @map("encrypted_data")
  encryptedPath String?   @map("encrypted_path")
  plainSize     Int?      @map("plain_size")
  encryptedSize Int?      @map("encrypted_size")
  createdAt     DateTime  @default(now())
  finalizedAt   DateTime? @map("finalized_at")
  audioFile     AudioFile @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, order])
}

model ActiveSession {
  id              String    @id @default(cuid())
  userId          Int       @map("user_id")
  deviceId        String    @map("device_id")
  deviceName      String?   @map("device_name")
  deviceType      String?   @map("device_type")
  deviceFingerprint String @map("device_fingerprint")
  ipAddress       String    @map("ip_address")
  userAgent       String    @map("user_agent")
  isActive        Boolean   @default(true) @map("is_active")
  lastActivity    DateTime  @default(now()) @map("last_activity")
  createdAt       DateTime  @default(now()) @map("created_at")
  expiresAt       DateTime  @map("expires_at")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@map("active_sessions")
}

model DeviceNotification {
  id          String   @id @default(cuid())
  userId      Int      @map("user_id")
  deviceId    String   @map("device_id")
  deviceName  String?  @map("device_name")
  ipAddress   String   @map("ip_address")
  location    String?
  isRead      Boolean  @default(false) @map("is_read")
  notificationType String @map("notification_type") // 'new_device', 'device_locked', 'suspicious_activity'
  createdAt   DateTime @default(now()) @map("created_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("device_notifications")
}

enum Role {
  user
  admin
}

model ChunkUploadSession {
  id          String   @id @default(cuid())
  uploadId    String   @unique @map("upload_id")
  fileName    String   @map("file_name")
  fileSize    Int      @map("file_size")
  fileHash    String   @map("file_hash")
  totalChunks Int      @map("total_chunks")
  uploadedChunks Int   @default(0) @map("uploaded_chunks")
  status      ChunkUploadStatus @default(pending)
  metadata    Json?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  expiresAt   DateTime @map("expires_at")

  @@map("chunk_upload_sessions")
}

enum ChapterStatus {
  pending
  ready
  failed
}

enum ChunkUploadStatus {
  pending
  uploading
  completed
  failed
  cancelled
}
